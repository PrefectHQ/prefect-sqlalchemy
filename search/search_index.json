{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-sqlalchemy","text":"<p>The prefect-sqlalchemy collection makes it easy to connect to a database in your Prefect flows. Check out the examples below to get started!</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#integrate-with-prefect-flows","title":"Integrate with Prefect flows","text":"<p>Prefect and SQLAlchemy are a data powerhouse duo. With Prefect, your data pipelines are always on track, and with SQLAlchemy, your databases are a snap to handle! Get ready to experience the ultimate data \"flow-chemistry\"!</p> <p>To set up a table, use the <code>execute</code> and <code>execute_many</code> methods. Then, use the <code>fetch_many</code> method to retrieve data in a stream until there's no more data.</p> <p>By using the <code>SqlAlchemyConnector</code> as a context manager, you can make sure that the SQLAlchemy engine and any connected resources are closed properly after you're done with them.</p> <p>Be sure to install prefect-sqlalchemy and save to block to run the examples below!</p> <p>Async support</p> <p><code>SqlAlchemyConnector</code> also supports async workflows! Just be sure to save, load, and use an async driver. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector, ConnectionComponents, AsyncDriver\n\nconnector = SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n        driver=AsyncDriver.SQLITE_AIOSQLITE,\n        database=\"DATABASE-PLACEHOLDER.db\"\n    )\n)\n\nconnector.save(\"BLOCK_NAME-PLACEHOLDER\")\n</code></pre></p> SyncAsync <pre><code>from prefect import flow, task\nfrom prefect_sqlalchemy import SqlAlchemyConnector\n\n\n@task\ndef setup_table(block_name: str) -&gt; None:\n    with SqlAlchemyConnector.load(block_name) as connector:\n        connector.execute(\n            \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n        )\n        connector.execute(\n            \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n            parameters={\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n        )\n        connector.execute_many(\n            \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n            seq_of_parameters=[\n                {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n            ],\n        )\n\n@task\ndef fetch_data(block_name: str) -&gt; list:\n    all_rows = []\n    with SqlAlchemyConnector.load(block_name) as connector:\n        while True:\n            # Repeated fetch* calls using the same operation will\n            # skip re-executing and instead return the next set of results\n            new_rows = connector.fetch_many(\"SELECT * FROM customers\", size=2)\n            if len(new_rows) == 0:\n                break\n            all_rows.append(new_rows)\n    return all_rows\n\n@flow\ndef sqlalchemy_flow(block_name: str) -&gt; list:\n    setup_table(block_name)\n    all_rows = fetch_data(block_name)\n    return all_rows\n\n\nsqlalchemy_flow(\"BLOCK-NAME-PLACEHOLDER\")\n</code></pre> <pre><code>from prefect import flow, task\nfrom prefect_sqlalchemy import SqlAlchemyConnector\nimport asyncio\n\n@task\nasync def setup_table(block_name: str) -&gt; None:\n    async with await SqlAlchemyConnector.load(block_name) as connector:\n        await connector.execute(\n            \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n        )\n        await connector.execute(\n            \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n            parameters={\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n        )\n        await connector.execute_many(\n            \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n            seq_of_parameters=[\n                {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                {\"name\": \"Unknown\", \"address\": \"Highway 42\"},\n            ],\n        )\n\n@task\nasync def fetch_data(block_name: str) -&gt; list:\n    all_rows = []\n    async with SqlAlchemyConnector.load(block_name) as connector:\n        while True:\n            # Repeated fetch* calls using the same operation will\n            # skip re-executing and instead return the next set of results\n            new_rows = await connector.fetch_many(\"SELECT * FROM customers\", size=2)\n            if len(new_rows) == 0:\n                break\n            all_rows.append(new_rows)\n    return all_rows\n\n@flow\nasync def sqlalchemy_flow(block_name: str) -&gt; list:\n    await setup_table(block_name)\n    all_rows = await fetch_data(block_name)\n    return all_rows\n\n\nasyncio.run(sqlalchemy_flow(\"BLOCK-NAME-PLACEHOLDER\"))\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-sqlalchemy</code> with <code>pip</code>:</p> <pre><code>pip install prefect-sqlalchemy\n</code></pre> <p>Requires an installation of Python 3.7+.</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.</p> <p>These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#saving-credentials-to-block","title":"Saving Credentials to Block","text":"<p>To use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p> <p>Below is a walkthrough on saving block documents through code; simply create a short script, replacing the placeholders. </p> <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector, ConnectionComponents, SyncDriver\n\nconnector = SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n        driver=SyncDriver.POSTGRESQL_PSYCOPG2,\n        username=\"USERNAME-PLACEHOLDER\",\n        password=\"PASSWORD-PLACEHOLDER\",\n        host=\"localhost\",\n        port=5432,\n        database=\"DATABASE-PLACEHOLDER\",\n    )\n)\n\nconnector.save(\"BLOCK_NAME-PLACEHOLDER\")\n</code></pre> <p>Congrats! You can now easily load the saved block, which holds your credentials:</p> <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nSqlAlchemyConnector.load(\"BLOCK_NAME-PLACEHOLDER\")\n</code></pre> <p>The required keywords depend on the desired <code>driver</code>. For example, sqlite only requires driver and database specified:</p> <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector, ConnectionComponents, SyncDriver\n\nconnector = SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n        driver=SyncDriver.SQLITE_PYSQLITE,\n        database=\"DATABASE-PLACEHOLDER.db\"\n    )\n)\n\nconnector.save(\"BLOCK_NAME-PLACEHOLDER\")\n</code></pre> <p>Registering blocks</p> <p>Register blocks in this module to view and edit them on Prefect Cloud:</p> <pre><code>prefect block register -m prefect_sqlalchemy\n</code></pre> <p>A list of available blocks in <code>prefect-sqlalchemy</code> and their setup instructions can be found here.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>If you encounter any bugs while using <code>prefect-sqlalchemy</code>, feel free to open an issue in the prefect-sqlalchemy repository.</p> <p>If you have any questions or issues while using <code>prefect-sqlalchemy</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community.</p> <p>Feel free to star or watch <code>prefect-sqlalchemy</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-sqlalchemy</code>, please propose changes through a pull request from a fork of the repository.</p> <p>Here are the steps:</p> <ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code>pip install -e \".[dev]\"\n</code></pre></li> <li>Make desired changes</li> <li>Add tests</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <pre><code>pre-commit install\n</code></pre></li> <li><code>git commit</code>, <code>git push</code>, and create a pull request</li> </ol>"},{"location":"blocks_catalog/","title":"Blocks Catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-sqlalchemy</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud, first install the required packages, then <pre><code>prefect block register -m prefect_sqlalchemy\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"blocks_catalog/#credentials-module","title":"Credentials Module","text":"<p>DatabaseCredentials</p> <p>Block used to manage authentication with a database.</p> <p>To load the DatabaseCredentials: <pre><code>from prefect import flow\nfrom prefect_sqlalchemy.credentials import DatabaseCredentials\n\n@flow\ndef my_flow():\n    my_block = DatabaseCredentials.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre> For additional examples, check out the Credentials Module under Examples Catalog.</p>"},{"location":"blocks_catalog/#database-module","title":"Database Module","text":"<p>SqlAlchemyConnector</p> <p>Block used to manage authentication with a database.</p> <p>Upon instantiating, an engine is created and maintained for the life of the object until the close method is called.</p> <p>It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited.</p> <p>It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor could be lost.</p> <p>To load the SqlAlchemyConnector: <pre><code>from prefect import flow\nfrom prefect_sqlalchemy.database import SqlAlchemyConnector\n\n@flow\ndef my_flow():\n    my_block = SqlAlchemyConnector.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre> For additional examples, check out the Database Module under Examples Catalog.</p>"},{"location":"credentials/","title":"Credentials","text":""},{"location":"credentials/#prefect_sqlalchemy.credentials","title":"<code>prefect_sqlalchemy.credentials</code>","text":"<p>Credential classes used to perform authenticated interactions with SQLAlchemy</p>"},{"location":"credentials/#prefect_sqlalchemy.credentials-classes","title":"Classes","text":""},{"location":"credentials/#prefect_sqlalchemy.credentials.AsyncDriver","title":"<code>AsyncDriver</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Known dialects with their corresponding async drivers.</p> <p>Attributes:</p> Name Type Description <code>POSTGRESQL_ASYNCPG</code> <code>Enum</code> <p>postgresql+asyncpg</p> <code>SQLITE_AIOSQLITE</code> <code>Enum</code> <p>sqlite+aiosqlite</p> <code>MYSQL_ASYNCMY</code> <code>Enum</code> <p>mysql+asyncmy</p> <code>MYSQL_AIOMYSQL</code> <code>Enum</code> <p>mysql+aiomysql</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>class AsyncDriver(Enum):\n\"\"\"\n    Known dialects with their corresponding async drivers.\n\n    Attributes:\n        POSTGRESQL_ASYNCPG (Enum): [postgresql+asyncpg](https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.asyncpg)\n\n        SQLITE_AIOSQLITE (Enum): [sqlite+aiosqlite](https://docs.sqlalchemy.org/en/14/dialects/sqlite.html#module-sqlalchemy.dialects.sqlite.aiosqlite)\n\n        MYSQL_ASYNCMY (Enum): [mysql+asyncmy](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.asyncmy)\n        MYSQL_AIOMYSQL (Enum): [mysql+aiomysql](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.aiomysql)\n    \"\"\"  # noqa\n\n    POSTGRESQL_ASYNCPG = \"postgresql+asyncpg\"\n\n    SQLITE_AIOSQLITE = \"sqlite+aiosqlite\"\n\n    MYSQL_ASYNCMY = \"mysql+asyncmy\"\n    MYSQL_AIOMYSQL = \"mysql+aiomysql\"\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.ConnectionComponents","title":"<code>ConnectionComponents</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Parameters to use to create a SQLAlchemy engine URL.</p> <p>Attributes:</p> Name Type Description <code>driver</code> <code>Union[AsyncDriver, SyncDriver, str]</code> <p>The driver name to use.</p> <code>database</code> <code>str</code> <p>The name of the database to use.</p> <code>username</code> <code>Optional[str]</code> <p>The user name used to authenticate.</p> <code>password</code> <code>Optional[SecretStr]</code> <p>The password used to authenticate.</p> <code>host</code> <code>Optional[str]</code> <p>The host address of the database.</p> <code>port</code> <code>Optional[str]</code> <p>The port to connect to the database.</p> <code>query</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary of string keys to string values to be passed to the dialect and/or the DBAPI upon connect.</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>class ConnectionComponents(BaseModel):\n\"\"\"\n    Parameters to use to create a SQLAlchemy engine URL.\n\n    Attributes:\n        driver: The driver name to use.\n        database: The name of the database to use.\n        username: The user name used to authenticate.\n        password: The password used to authenticate.\n        host: The host address of the database.\n        port: The port to connect to the database.\n        query: A dictionary of string keys to string values to be passed to the dialect\n            and/or the DBAPI upon connect.\n    \"\"\"\n\n    driver: Union[AsyncDriver, SyncDriver, str] = Field(\n        default=..., description=\"The driver name to use.\"\n    )\n    database: str = Field(default=..., description=\"The name of the database to use.\")\n    username: Optional[str] = Field(\n        default=None, description=\"The user name used to authenticate.\"\n    )\n    password: Optional[SecretStr] = Field(\n        default=None, description=\"The password used to authenticate.\"\n    )\n    host: Optional[str] = Field(\n        default=None, description=\"The host address of the database.\"\n    )\n    port: Optional[str] = Field(\n        default=None, description=\"The port to connect to the database.\"\n    )\n    query: Optional[Dict[str, str]] = Field(\n        default=None,\n        description=(\n            \"A dictionary of string keys to string values to be passed to the dialect \"\n            \"and/or the DBAPI upon connect. To specify non-string parameters to a \"\n            \"Python DBAPI directly, use connect_args.\"\n        ),\n    )\n\n    def create_url(self) -&gt; URL:\n\"\"\"\n        Create a fully formed connection URL.\n\n        Returns:\n            The SQLAlchemy engine URL.\n        \"\"\"\n        driver = self.driver\n        drivername = driver.value if isinstance(driver, Enum) else driver\n        password = self.password.get_secret_value() if self.password else None\n        url_params = dict(\n            drivername=drivername,\n            username=self.username,\n            password=password,\n            database=self.database,\n            host=self.host,\n            port=self.port,\n            query=self.query,\n        )\n        return URL.create(\n            **{\n                url_key: url_param\n                for url_key, url_param in url_params.items()\n                if url_param is not None\n            }\n        )\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.ConnectionComponents-functions","title":"Functions","text":""},{"location":"credentials/#prefect_sqlalchemy.credentials.ConnectionComponents.create_url","title":"<code>create_url</code>","text":"<p>Create a fully formed connection URL.</p> <p>Returns:</p> Type Description <code>URL</code> <p>The SQLAlchemy engine URL.</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>def create_url(self) -&gt; URL:\n\"\"\"\n    Create a fully formed connection URL.\n\n    Returns:\n        The SQLAlchemy engine URL.\n    \"\"\"\n    driver = self.driver\n    drivername = driver.value if isinstance(driver, Enum) else driver\n    password = self.password.get_secret_value() if self.password else None\n    url_params = dict(\n        drivername=drivername,\n        username=self.username,\n        password=password,\n        database=self.database,\n        host=self.host,\n        port=self.port,\n        query=self.query,\n    )\n    return URL.create(\n        **{\n            url_key: url_param\n            for url_key, url_param in url_params.items()\n            if url_param is not None\n        }\n    )\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials","title":"<code>DatabaseCredentials</code>","text":"<p>         Bases: <code>Block</code></p> <p>Block used to manage authentication with a database.</p> <p>Attributes:</p> Name Type Description <code>driver</code> <code>Optional[Union[AsyncDriver, SyncDriver, str]]</code> <p>The driver name, e.g. \"postgresql+asyncpg\"</p> <code>database</code> <code>Optional[str]</code> <p>The name of the database to use.</p> <code>username</code> <code>Optional[str]</code> <p>The user name used to authenticate.</p> <code>password</code> <code>Optional[SecretStr]</code> <p>The password used to authenticate.</p> <code>host</code> <code>Optional[str]</code> <p>The host address of the database.</p> <code>port</code> <code>Optional[str]</code> <p>The port to connect to the database.</p> <code>query</code> <code>Optional[Dict[str, str]]</code> <p>A dictionary of string keys to string values to be passed to the dialect and/or the DBAPI upon connect. To specify non-string parameters to a Python DBAPI directly, use connect_args.</p> <code>url</code> <code>Optional[AnyUrl]</code> <p>Manually create and provide a URL to create the engine, this is useful for external dialects, e.g. Snowflake, because some of the params, such as \"warehouse\", is not directly supported in the vanilla <code>sqlalchemy.engine.URL.create</code> method; do not provide this alongside with other URL params as it will raise a <code>ValueError</code>.</p> <code>connect_args</code> <code>Optional[Dict[str, Any]]</code> <p>The options which will be passed directly to the DBAPI's connect() method as additional keyword arguments.</p> Example <p>Load stored database credentials: <pre><code>from prefect_sqlalchemy import DatabaseCredentials\ndatabase_block = DatabaseCredentials.load(\"BLOCK_NAME\")\n</code></pre></p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>class DatabaseCredentials(Block):\n\"\"\"\n    Block used to manage authentication with a database.\n\n    Attributes:\n        driver: The driver name, e.g. \"postgresql+asyncpg\"\n        database: The name of the database to use.\n        username: The user name used to authenticate.\n        password: The password used to authenticate.\n        host: The host address of the database.\n        port: The port to connect to the database.\n        query: A dictionary of string keys to string values to be passed to\n            the dialect and/or the DBAPI upon connect. To specify non-string\n            parameters to a Python DBAPI directly, use connect_args.\n        url: Manually create and provide a URL to create the engine,\n            this is useful for external dialects, e.g. Snowflake, because some\n            of the params, such as \"warehouse\", is not directly supported in\n            the vanilla `sqlalchemy.engine.URL.create` method; do not provide\n            this alongside with other URL params as it will raise a `ValueError`.\n        connect_args: The options which will be passed directly to the\n            DBAPI's connect() method as additional keyword arguments.\n\n    Example:\n        Load stored database credentials:\n        ```python\n        from prefect_sqlalchemy import DatabaseCredentials\n        database_block = DatabaseCredentials.load(\"BLOCK_NAME\")\n        ```\n    \"\"\"\n\n    _block_type_name = \"Database Credentials\"\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/3xLant5G70S4vJpmdWCYmr/8fdb19f15b97c3a07c3af3efde4d28fb/download.svg.png?h=250\"  # noqa\n    _documentation_url = \"https://prefecthq.github.io/prefect-sqlalchemy/credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials\"  # noqa\n\n    driver: Optional[Union[AsyncDriver, SyncDriver, str]] = Field(\n        default=None, description=\"The driver name to use.\"\n    )\n    username: Optional[str] = Field(\n        default=None, description=\"The user name used to authenticate.\"\n    )\n    password: Optional[SecretStr] = Field(\n        default=None, description=\"The password used to authenticate.\"\n    )\n    database: Optional[str] = Field(\n        default=None, description=\"The name of the database to use.\"\n    )\n    host: Optional[str] = Field(\n        default=None, description=\"The host address of the database.\"\n    )\n    port: Optional[str] = Field(\n        default=None, description=\"The port to connect to the database.\"\n    )\n    query: Optional[Dict[str, str]] = Field(\n        default=None,\n        description=(\n            \"A dictionary of string keys to string values to be passed to the dialect \"\n            \"and/or the DBAPI upon connect. To specify non-string parameters to a \"\n            \"Python DBAPI directly, use connect_args.\"\n        ),\n    )\n    url: Optional[AnyUrl] = Field(\n        default=None,\n        description=(\n            \"Manually create and provide a URL to create the engine, this is useful \"\n            \"for external dialects, e.g. Snowflake, because some of the params, \"\n            \"such as 'warehouse', is not directly supported in the vanilla \"\n            \"`sqlalchemy.engine.URL.create` method; do not provide this \"\n            \"alongside with other URL params as it will raise a `ValueError`.\"\n        ),\n    )\n    connect_args: Optional[Dict[str, Any]] = Field(\n        default=None,\n        description=(\n            \"The options which will be passed directly to the DBAPI's connect() \"\n            \"method as additional keyword arguments.\"\n        ),\n    )\n\n    def block_initialization(self):\n\"\"\"\n        Initializes the engine.\n        \"\"\"\n        warnings.warn(\n            \"DatabaseCredentials is now deprecated and will be removed March 2023; \"\n            \"please use SqlAlchemyConnector instead.\",\n            DeprecationWarning,\n        )\n        if isinstance(self.driver, AsyncDriver):\n            drivername = self.driver.value\n            self._driver_is_async = True\n        elif isinstance(self.driver, SyncDriver):\n            drivername = self.driver.value\n            self._driver_is_async = False\n        else:\n            drivername = self.driver\n            self._driver_is_async = drivername in AsyncDriver._value2member_map_\n\n        url_params = dict(\n            drivername=drivername,\n            username=self.username,\n            password=self.password.get_secret_value() if self.password else None,\n            database=self.database,\n            host=self.host,\n            port=self.port,\n            query=self.query,\n        )\n        if not self.url:\n            required_url_keys = (\"drivername\", \"database\")\n            if not all(url_params[key] for key in required_url_keys):\n                required_url_keys = (\"driver\", \"database\")\n                raise ValueError(\n                    f\"If the `url` is not provided, \"\n                    f\"all of these URL params are required: \"\n                    f\"{required_url_keys}\"\n                )\n            self.rendered_url = URL.create(\n                **{\n                    url_key: url_param\n                    for url_key, url_param in url_params.items()\n                    if url_param is not None\n                }\n            )  # from params\n        else:\n            if any(val for val in url_params.values()):\n                raise ValueError(\n                    f\"The `url` should not be provided \"\n                    f\"alongside any of these URL params: \"\n                    f\"{url_params.keys()}\"\n                )\n            self.rendered_url = make_url(str(self.url))\n\n    def get_engine(self) -&gt; Union[\"Connection\", \"AsyncConnection\"]:\n\"\"\"\n        Returns an authenticated engine that can be\n        used to query from databases.\n\n        Returns:\n            The authenticated SQLAlchemy Connection / AsyncConnection.\n\n        Examples:\n            Create an asynchronous engine to PostgreSQL using URL params.\n            ```python\n            from prefect import flow\n            from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n            @flow\n            def sqlalchemy_credentials_flow():\n                sqlalchemy_credentials = DatabaseCredentials(\n                    driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n                    username=\"prefect\",\n                    password=\"prefect_password\",\n                    database=\"postgres\"\n                )\n                print(sqlalchemy_credentials.get_engine())\n\n            sqlalchemy_credentials_flow()\n            ```\n\n            Create a synchronous engine to Snowflake using the `url` kwarg.\n            ```python\n            from prefect import flow\n            from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n            @flow\n            def sqlalchemy_credentials_flow():\n                url = (\n                    \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n                    \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n                    \"?warehouse=&lt;warehouse_name&gt;\"\n                )\n                sqlalchemy_credentials = DatabaseCredentials(url=url)\n                print(sqlalchemy_credentials.get_engine())\n\n            sqlalchemy_credentials_flow()\n            ```\n        \"\"\"\n        engine_kwargs = dict(\n            url=self.rendered_url,\n            connect_args=self.connect_args or {},\n            poolclass=NullPool,\n        )\n        if self._driver_is_async:\n            engine = create_async_engine(**engine_kwargs)\n        else:\n            engine = create_engine(**engine_kwargs)\n        return engine\n\n    class Config:\n\"\"\"Configuration of pydantic.\"\"\"\n\n        # Support serialization of the 'URL' type\n        arbitrary_types_allowed = True\n        json_encoders = {URL: lambda u: u.render_as_string()}\n\n    def dict(self, *args, **kwargs) -&gt; Dict:\n\"\"\"\n        Convert to a dictionary.\n        \"\"\"\n        # Support serialization of the 'URL' type\n        d = super().dict(*args, **kwargs)\n        d[\"rendered_url\"] = SecretStr(\n            self.rendered_url.render_as_string(hide_password=False)\n        )\n        return d\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials-classes","title":"Classes","text":""},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials.Config","title":"<code>Config</code>","text":"<p>Configuration of pydantic.</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>class Config:\n\"\"\"Configuration of pydantic.\"\"\"\n\n    # Support serialization of the 'URL' type\n    arbitrary_types_allowed = True\n    json_encoders = {URL: lambda u: u.render_as_string()}\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials-functions","title":"Functions","text":""},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials.block_initialization","title":"<code>block_initialization</code>","text":"<p>Initializes the engine.</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>def block_initialization(self):\n\"\"\"\n    Initializes the engine.\n    \"\"\"\n    warnings.warn(\n        \"DatabaseCredentials is now deprecated and will be removed March 2023; \"\n        \"please use SqlAlchemyConnector instead.\",\n        DeprecationWarning,\n    )\n    if isinstance(self.driver, AsyncDriver):\n        drivername = self.driver.value\n        self._driver_is_async = True\n    elif isinstance(self.driver, SyncDriver):\n        drivername = self.driver.value\n        self._driver_is_async = False\n    else:\n        drivername = self.driver\n        self._driver_is_async = drivername in AsyncDriver._value2member_map_\n\n    url_params = dict(\n        drivername=drivername,\n        username=self.username,\n        password=self.password.get_secret_value() if self.password else None,\n        database=self.database,\n        host=self.host,\n        port=self.port,\n        query=self.query,\n    )\n    if not self.url:\n        required_url_keys = (\"drivername\", \"database\")\n        if not all(url_params[key] for key in required_url_keys):\n            required_url_keys = (\"driver\", \"database\")\n            raise ValueError(\n                f\"If the `url` is not provided, \"\n                f\"all of these URL params are required: \"\n                f\"{required_url_keys}\"\n            )\n        self.rendered_url = URL.create(\n            **{\n                url_key: url_param\n                for url_key, url_param in url_params.items()\n                if url_param is not None\n            }\n        )  # from params\n    else:\n        if any(val for val in url_params.values()):\n            raise ValueError(\n                f\"The `url` should not be provided \"\n                f\"alongside any of these URL params: \"\n                f\"{url_params.keys()}\"\n            )\n        self.rendered_url = make_url(str(self.url))\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials.dict","title":"<code>dict</code>","text":"<p>Convert to a dictionary.</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>def dict(self, *args, **kwargs) -&gt; Dict:\n\"\"\"\n    Convert to a dictionary.\n    \"\"\"\n    # Support serialization of the 'URL' type\n    d = super().dict(*args, **kwargs)\n    d[\"rendered_url\"] = SecretStr(\n        self.rendered_url.render_as_string(hide_password=False)\n    )\n    return d\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.DatabaseCredentials.get_engine","title":"<code>get_engine</code>","text":"<p>Returns an authenticated engine that can be used to query from databases.</p> <p>Returns:</p> Type Description <code>Union[Connection, AsyncConnection]</code> <p>The authenticated SQLAlchemy Connection / AsyncConnection.</p> <p>Examples:</p> <p>Create an asynchronous engine to PostgreSQL using URL params. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n@flow\ndef sqlalchemy_credentials_flow():\n    sqlalchemy_credentials = DatabaseCredentials(\n        driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n        username=\"prefect\",\n        password=\"prefect_password\",\n        database=\"postgres\"\n    )\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p> <p>Create a synchronous engine to Snowflake using the <code>url</code> kwarg. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n@flow\ndef sqlalchemy_credentials_flow():\n    url = (\n        \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n        \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n        \"?warehouse=&lt;warehouse_name&gt;\"\n    )\n    sqlalchemy_credentials = DatabaseCredentials(url=url)\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>def get_engine(self) -&gt; Union[\"Connection\", \"AsyncConnection\"]:\n\"\"\"\n    Returns an authenticated engine that can be\n    used to query from databases.\n\n    Returns:\n        The authenticated SQLAlchemy Connection / AsyncConnection.\n\n    Examples:\n        Create an asynchronous engine to PostgreSQL using URL params.\n        ```python\n        from prefect import flow\n        from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n        @flow\n        def sqlalchemy_credentials_flow():\n            sqlalchemy_credentials = DatabaseCredentials(\n                driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n                username=\"prefect\",\n                password=\"prefect_password\",\n                database=\"postgres\"\n            )\n            print(sqlalchemy_credentials.get_engine())\n\n        sqlalchemy_credentials_flow()\n        ```\n\n        Create a synchronous engine to Snowflake using the `url` kwarg.\n        ```python\n        from prefect import flow\n        from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n        @flow\n        def sqlalchemy_credentials_flow():\n            url = (\n                \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n                \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n                \"?warehouse=&lt;warehouse_name&gt;\"\n            )\n            sqlalchemy_credentials = DatabaseCredentials(url=url)\n            print(sqlalchemy_credentials.get_engine())\n\n        sqlalchemy_credentials_flow()\n        ```\n    \"\"\"\n    engine_kwargs = dict(\n        url=self.rendered_url,\n        connect_args=self.connect_args or {},\n        poolclass=NullPool,\n    )\n    if self._driver_is_async:\n        engine = create_async_engine(**engine_kwargs)\n    else:\n        engine = create_engine(**engine_kwargs)\n    return engine\n</code></pre>"},{"location":"credentials/#prefect_sqlalchemy.credentials.SyncDriver","title":"<code>SyncDriver</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Known dialects with their corresponding sync drivers.</p> <p>Attributes:</p> Name Type Description <code>POSTGRESQL_PSYCOPG2</code> <code>Enum</code> <p>postgresql+psycopg2</p> <code>POSTGRESQL_PG8000</code> <code>Enum</code> <p>postgresql+pg8000</p> <code>POSTGRESQL_PSYCOPG2CFFI</code> <code>Enum</code> <p>postgresql+psycopg2cffi</p> <code>POSTGRESQL_PYPOSTGRESQL</code> <code>Enum</code> <p>postgresql+pypostgresql</p> <code>POSTGRESQL_PYGRESQL</code> <code>Enum</code> <p>postgresql+pygresql</p> <code>MYSQL_MYSQLDB</code> <code>Enum</code> <p>mysql+mysqldb</p> <code>MYSQL_PYMYSQL</code> <code>Enum</code> <p>mysql+pymysql</p> <code>MYSQL_MYSQLCONNECTOR</code> <code>Enum</code> <p>mysql+mysqlconnector</p> <code>MYSQL_CYMYSQL</code> <code>Enum</code> <p>mysql+cymysql</p> <code>MYSQL_OURSQL</code> <code>Enum</code> <p>mysql+oursql</p> <code>MYSQL_PYODBC</code> <code>Enum</code> <p>mysql+pyodbc</p> <code>SQLITE_PYSQLITE</code> <code>Enum</code> <p>sqlite+pysqlite</p> <code>SQLITE_PYSQLCIPHER</code> <code>Enum</code> <p>sqlite+pysqlcipher</p> <code>ORACLE_CX_ORACLE</code> <code>Enum</code> <p>oracle+cx_oracle</p> <code>MSSQL_PYODBC</code> <code>Enum</code> <p>mssql+pyodbc</p> <code>MSSQL_MXODBC</code> <code>Enum</code> <p>mssql+mxodbc</p> <code>MSSQL_PYMSSQL</code> <code>Enum</code> <p>mssql+pymssql</p> Source code in <code>prefect_sqlalchemy/credentials.py</code> <pre><code>class SyncDriver(Enum):\n\"\"\"\n    Known dialects with their corresponding sync drivers.\n\n    Attributes:\n        POSTGRESQL_PSYCOPG2 (Enum): [postgresql+psycopg2](https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2)\n        POSTGRESQL_PG8000 (Enum): [postgresql+pg8000](https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.pg8000)\n        POSTGRESQL_PSYCOPG2CFFI (Enum): [postgresql+psycopg2cffi](https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi)\n        POSTGRESQL_PYPOSTGRESQL (Enum): [postgresql+pypostgresql](https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.pypostgresql)\n        POSTGRESQL_PYGRESQL (Enum): [postgresql+pygresql](https://docs.sqlalchemy.org/en/14/dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.pygresql)\n\n        MYSQL_MYSQLDB (Enum): [mysql+mysqldb](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.mysqldb)\n        MYSQL_PYMYSQL (Enum): [mysql+pymysql](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)\n        MYSQL_MYSQLCONNECTOR (Enum): [mysql+mysqlconnector](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.mysqlconnector)\n        MYSQL_CYMYSQL (Enum): [mysql+cymysql](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.cymysql)\n        MYSQL_OURSQL (Enum): [mysql+oursql](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.oursql)\n        MYSQL_PYODBC (Enum): [mysql+pyodbc](https://docs.sqlalchemy.org/en/14/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pyodbc)\n\n        SQLITE_PYSQLITE (Enum): [sqlite+pysqlite](https://docs.sqlalchemy.org/en/14/dialects/sqlite.html#module-sqlalchemy.dialects.sqlite.pysqlite)\n        SQLITE_PYSQLCIPHER (Enum): [sqlite+pysqlcipher](https://docs.sqlalchemy.org/en/14/dialects/sqlite.html#module-sqlalchemy.dialects.sqlite.pysqlcipher)\n\n        ORACLE_CX_ORACLE (Enum): [oracle+cx_oracle](https://docs.sqlalchemy.org/en/14/dialects/oracle.html#module-sqlalchemy.dialects.oracle.cx_oracle)\n\n        MSSQL_PYODBC (Enum): [mssql+pyodbc](https://docs.sqlalchemy.org/en/14/dialects/mssql.html#module-sqlalchemy.dialects.mssql.pyodbc)\n        MSSQL_MXODBC (Enum): [mssql+mxodbc](https://docs.sqlalchemy.org/en/14/dialects/mssql.html#module-sqlalchemy.dialects.mssql.mxodbc)\n        MSSQL_PYMSSQL (Enum): [mssql+pymssql](https://docs.sqlalchemy.org/en/14/dialects/mssql.html#module-sqlalchemy.dialects.mssql.pymssql)\n    \"\"\"  # noqa\n\n    POSTGRESQL_PSYCOPG2 = \"postgresql+psycopg2\"\n    POSTGRESQL_PG8000 = \"postgresql+pg8000\"\n    POSTGRESQL_PSYCOPG2CFFI = \"postgresql+psycopg2cffi\"\n    POSTGRESQL_PYPOSTGRESQL = \"postgresql+pypostgresql\"\n    POSTGRESQL_PYGRESQL = \"postgresql+pygresql\"\n\n    MYSQL_MYSQLDB = \"mysql+mysqldb\"\n    MYSQL_PYMYSQL = \"mysql+pymysql\"\n    MYSQL_MYSQLCONNECTOR = \"mysql+mysqlconnector\"\n    MYSQL_CYMYSQL = \"mysql+cymysql\"\n    MYSQL_OURSQL = \"mysql+oursql\"\n    MYSQL_PYODBC = \"mysql+pyodbc\"\n\n    SQLITE_PYSQLITE = \"sqlite+pysqlite\"\n    SQLITE_PYSQLCIPHER = \"sqlite+pysqlcipher\"\n\n    ORACLE_CX_ORACLE = \"oracle+cx_oracle\"\n\n    MSSQL_PYODBC = \"mssql+pyodbc\"\n    MSSQL_MXODBC = \"mssql+mxodbc\"\n    MSSQL_PYMSSQL = \"mssql+pymssql\"\n</code></pre>"},{"location":"database/","title":"Database","text":""},{"location":"database/#prefect_sqlalchemy.database","title":"<code>prefect_sqlalchemy.database</code>","text":"<p>Tasks for querying a database with SQLAlchemy</p>"},{"location":"database/#prefect_sqlalchemy.database-classes","title":"Classes","text":""},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector","title":"<code>SqlAlchemyConnector</code>","text":"<p>         Bases: <code>CredentialsBlock</code>, <code>DatabaseBlock</code></p> <p>Block used to manage authentication with a database.</p> <p>Upon instantiating, an engine is created and maintained for the life of the object until the close method is called.</p> <p>It is recommended to use this block as a context manager, which will automatically close the engine and its connections when the context is exited.</p> <p>It is also recommended that this block is loaded and consumed within a single task or flow because if the block is passed across separate tasks and flows, the state of the block's connection and cursor could be lost.</p> <p>Attributes:</p> Name Type Description <code>connection_info</code> <code>Union[ConnectionComponents, AnyUrl]</code> <p>SQLAlchemy URL to create the engine; either create from components or create from a string.</p> <code>connect_args</code> <code>Optional[Dict[str, Any]]</code> <p>The options which will be passed directly to the DBAPI's connect() method as additional keyword arguments.</p> <code>fetch_size</code> <code>int</code> <p>The number of rows to fetch at a time.</p> Example <p>Load stored database credentials and use in context manager: <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\ndatabase_block = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nwith database_block:\n    ...\n</code></pre></p> <p>Create table named customers and insert values; then fetch the first 10 rows. <pre><code>from prefect_sqlalchemy import (\n    SqlAlchemyConnector, SyncDriver, ConnectionComponents\n)\n\nwith SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n        driver=SyncDriver.SQLITE_PYSQLITE,\n        database=\"prefect.db\"\n    )\n) as database:\n    database.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\",\n    )\n    for i in range(1, 42):\n        database.execute(\n            \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n            parameters={\"name\": \"Marvin\", \"address\": f\"Highway {i}\"},\n        )\n    results = database.fetch_many(\n        \"SELECT * FROM customers WHERE name = :name;\",\n        parameters={\"name\": \"Marvin\"},\n        size=10\n    )\nprint(results)\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>class SqlAlchemyConnector(CredentialsBlock, DatabaseBlock):\n\"\"\"\n    Block used to manage authentication with a database.\n\n    Upon instantiating, an engine is created and maintained for the life of\n    the object until the close method is called.\n\n    It is recommended to use this block as a context manager, which will automatically\n    close the engine and its connections when the context is exited.\n\n    It is also recommended that this block is loaded and consumed within a single task\n    or flow because if the block is passed across separate tasks and flows,\n    the state of the block's connection and cursor could be lost.\n\n    Attributes:\n        connection_info: SQLAlchemy URL to create the engine;\n            either create from components or create from a string.\n        connect_args: The options which will be passed directly to the\n            DBAPI's connect() method as additional keyword arguments.\n        fetch_size: The number of rows to fetch at a time.\n\n    Example:\n        Load stored database credentials and use in context manager:\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        database_block = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n        with database_block:\n            ...\n        ```\n\n        Create table named customers and insert values; then fetch the first 10 rows.\n        ```python\n        from prefect_sqlalchemy import (\n            SqlAlchemyConnector, SyncDriver, ConnectionComponents\n        )\n\n        with SqlAlchemyConnector(\n            connection_info=ConnectionComponents(\n                driver=SyncDriver.SQLITE_PYSQLITE,\n                database=\"prefect.db\"\n            )\n        ) as database:\n            database.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\",\n            )\n            for i in range(1, 42):\n                database.execute(\n                    \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                    parameters={\"name\": \"Marvin\", \"address\": f\"Highway {i}\"},\n                )\n            results = database.fetch_many(\n                \"SELECT * FROM customers WHERE name = :name;\",\n                parameters={\"name\": \"Marvin\"},\n                size=10\n            )\n        print(results)\n        ```\n    \"\"\"\n\n    _block_type_name = \"SQLAlchemy Connector\"\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/37TOcxeP9kfXffpKVRAHiJ/0f359112e79d0bd3dfe38c73c4fc6363/sqlalchemy.png?h=250\"  # noqa\n    _documentation_url = \"https://prefecthq.github.io/prefect-sqlalchemy/database/#prefect_sqlalchemy.database.SqlAlchemyConnector\"  # noqa\n\n    connection_info: Union[ConnectionComponents, AnyUrl] = Field(\n        default=...,\n        description=(\n            \"SQLAlchemy URL to create the engine; either create from components \"\n            \"or create from a string.\"\n        ),\n    )\n    connect_args: Optional[Dict[str, Any]] = Field(\n        default=None,\n        title=\"Additional Connection Arguments\",\n        description=(\n            \"The options which will be passed directly to the DBAPI's connect() \"\n            \"method as additional keyword arguments.\"\n        ),\n    )\n    fetch_size: int = Field(\n        default=1, description=\"The number of rows to fetch at a time.\"\n    )\n\n    _engine: Optional[Union[AsyncEngine, Engine]] = None\n    _exit_stack: Union[ExitStack, AsyncExitStack] = None\n    _unique_results: Dict[str, CursorResult] = None\n\n    class Config:\n\"\"\"Configuration of pydantic.\"\"\"\n\n        # Support serialization of the 'URL' type\n        arbitrary_types_allowed = True\n        json_encoders = {URL: lambda u: u.render_as_string()}\n\n    def dict(self, *args, **kwargs) -&gt; Dict:\n\"\"\"\n        Convert to a dictionary.\n        \"\"\"\n        # Support serialization of the 'URL' type\n        d = super().dict(*args, **kwargs)\n        d[\"_rendered_url\"] = SecretStr(\n            self._rendered_url.render_as_string(hide_password=False)\n        )\n        return d\n\n    def block_initialization(self):\n\"\"\"\n        Initializes the engine.\n        \"\"\"\n        super().block_initialization()\n\n        if isinstance(self.connection_info, ConnectionComponents):\n            self._rendered_url = self.connection_info.create_url()\n        else:\n            # make rendered url from string\n            self._rendered_url = make_url(str(self.connection_info))\n        drivername = self._rendered_url.drivername\n\n        try:\n            AsyncDriver(drivername)\n            self._driver_is_async = True\n        except ValueError:\n            self._driver_is_async = False\n\n    def _start_exit_stack(self):\n\"\"\"\n        Starts an AsyncExitStack or ExitStack depending on whether driver is async.\n        \"\"\"\n        self._exit_stack = AsyncExitStack() if self._driver_is_async else ExitStack()\n\n    def get_engine(\n        self, **create_engine_kwargs: Dict[str, Any]\n    ) -&gt; Union[Engine, AsyncEngine]:\n\"\"\"\n        Returns an authenticated engine that can be\n        used to query from databases.\n\n        If an existing engine exists, return that one.\n\n        Returns:\n            The authenticated SQLAlchemy Engine / AsyncEngine.\n\n        Examples:\n            Create an asynchronous engine to PostgreSQL using URL params.\n            ```python\n            from prefect import flow\n            from prefect_sqlalchemy import (\n                SqlAlchemyConnector, ConnectionComponents, AsyncDriver\n            )\n\n            @flow\n            def sqlalchemy_credentials_flow():\n                sqlalchemy_credentials = SqlAlchemyConnector(\n                connection_info=ConnectionComponents(\n                        driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n                        username=\"prefect\",\n                        password=\"prefect_password\",\n                        database=\"postgres\"\n                    )\n                )\n                print(sqlalchemy_credentials.get_engine())\n\n            sqlalchemy_credentials_flow()\n            ```\n\n            Create a synchronous engine to Snowflake using the `url` kwarg.\n            ```python\n            from prefect import flow\n            from prefect_sqlalchemy import SqlAlchemyConnector, AsyncDriver\n\n            @flow\n            def sqlalchemy_credentials_flow():\n                url = (\n                    \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n                    \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n                    \"?warehouse=&lt;warehouse_name&gt;\"\n                )\n                sqlalchemy_credentials = SqlAlchemyConnector(url=url)\n                print(sqlalchemy_credentials.get_engine())\n\n            sqlalchemy_credentials_flow()\n            ```\n        \"\"\"\n        if self._engine is not None:\n            self.logger.debug(\"Reusing existing engine.\")\n            return self._engine\n\n        engine_kwargs = dict(\n            url=self._rendered_url,\n            connect_args=self.connect_args or {},\n            **create_engine_kwargs,\n        )\n        if self._driver_is_async:\n            # no need to await here\n            engine = create_async_engine(**engine_kwargs)\n        else:\n            engine = create_engine(**engine_kwargs)\n        self.logger.info(\"Created a new engine.\")\n\n        if self._engine is None:\n            self._engine = engine\n        if self._exit_stack is None:\n            self._start_exit_stack()\n        if self._unique_results is None:\n            self._unique_results = {}\n\n        return engine\n\n    def get_connection(\n        self, begin: bool = True, **connect_kwargs: Dict[str, Any]\n    ) -&gt; Union[Connection, AsyncConnection]:\n\"\"\"\n        Returns a connection that can be used to query from databases.\n\n        Args:\n            begin: Whether to begin a transaction on the connection; if True, if\n                any operations fail, the entire transaction will be rolled back.\n            **connect_kwargs: Additional keyword arguments to pass to either\n                `engine.begin` or engine.connect`.\n\n        Returns:\n            The SQLAlchemy Connection / AsyncConnection.\n\n        Examples:\n            Create an synchronous connection as a context-managed transaction.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n            with sqlalchemy_connector.get_connection(begin=False) as connection:\n                connection.execute(\"SELECT * FROM table LIMIT 1;\")\n            ```\n\n            Create an asynchronous connection as a context-managed transacation.\n            ```python\n            import asyncio\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n            async with sqlalchemy_connector.get_connection(begin=False) as connection:\n                asyncio.run(connection.execute(\"SELECT * FROM table LIMIT 1;\"))\n            ```\n        \"\"\"  # noqa: E501\n        engine = self.get_engine()\n        if begin:\n            connection = engine.begin(**connect_kwargs)\n        else:\n            connection = engine.connect(**connect_kwargs)\n        self.logger.info(\"Created a new connection.\")\n        return connection\n\n    def get_client(\n        self,\n        client_type: Literal[\"engine\", \"connection\"],\n        **get_client_kwargs: Dict[str, Any],\n    ) -&gt; Union[Engine, AsyncEngine, Connection, AsyncConnection]:\n\"\"\"\n        Returns either an engine or connection that can be used to query from databases.\n\n        Args:\n            client_type: Select from either 'engine' or 'connection'.\n            **get_client_kwargs: Additional keyword arguments to pass to\n                either `get_engine` or `get_connection`.\n\n        Returns:\n            The authenticated SQLAlchemy engine or connection.\n\n        Examples:\n            Create an engine.\n            ```python\n            from prefect_sqlalchemy import SqlalchemyConnector\n\n            sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n            engine = sqlalchemy_connector.get_client(client_type=\"engine\")\n            ```\n\n            Create a context managed connection.\n            ```python\n            from prefect_sqlalchemy import SqlalchemyConnector\n\n            sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n            with sqlalchemy_connector.get_client(client_type=\"connection\") as conn:\n                ...\n            ```\n        \"\"\"  # noqa: E501\n        if client_type == \"engine\":\n            client = self.get_engine(**get_client_kwargs)\n        elif client_type == \"connection\":\n            client = self.get_connection(**get_client_kwargs)\n        else:\n            raise ValueError(\n                f\"{client_type!r} is not supported; choose from engine or connection.\"\n            )\n        return client\n\n    async def _async_sync_execute(\n        self,\n        connection: Union[Connection, AsyncConnection],\n        *execute_args: Tuple[Any],\n        **execute_kwargs: Dict[str, Any],\n    ) -&gt; CursorResult:\n\"\"\"\n        Execute the statement asynchronously or synchronously.\n        \"\"\"\n        # can't use run_sync_in_worker_thread:\n        # ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a\n        # thread can only be used in that same thread.\n        result_set = connection.execute(*execute_args, **execute_kwargs)\n\n        if self._driver_is_async:\n            result_set = await result_set\n            await connection.commit()  # very important\n        return result_set\n\n    @asynccontextmanager\n    async def _manage_connection(self, **get_connection_kwargs: Dict[str, Any]):\n        if self._driver_is_async:\n            async with self.get_connection(**get_connection_kwargs) as connection:\n                yield connection\n        else:\n            with self.get_connection(**get_connection_kwargs) as connection:\n                yield connection\n\n    async def _get_result_set(\n        self, *execute_args: Tuple[Any], **execute_kwargs: Dict[str, Any]\n    ) -&gt; CursorResult:\n\"\"\"\n        Returns a new or existing result set based on whether the inputs\n        are unique.\n\n        Args:\n            *execute_args: Args to pass to execute.\n            **execute_kwargs: Keyword args to pass to execute.\n\n        Returns:\n            The result set from the operation.\n        \"\"\"  # noqa: E501\n        input_hash = hash_objects(*execute_args, **execute_kwargs)\n        assert input_hash is not None, (\n            \"We were not able to hash your inputs, \"\n            \"which resulted in an unexpected data return; \"\n            \"please open an issue with a reproducible example.\"\n        )\n\n        if input_hash not in self._unique_results.keys():\n            if self._driver_is_async:\n                connection = await self._exit_stack.enter_async_context(\n                    self.get_connection()\n                )\n            else:\n                connection = self._exit_stack.enter_context(self.get_connection())\n            result_set = await self._async_sync_execute(\n                connection, *execute_args, **execute_kwargs\n            )\n            # implicitly store the connection by storing the result set\n            # which points to its parent connection\n            self._unique_results[input_hash] = result_set\n        else:\n            result_set = self._unique_results[input_hash]\n        return result_set\n\n    def _reset_cursor_results(self) -&gt; None:\n\"\"\"\n        Closes all the existing cursor results.\n        \"\"\"\n        input_hashes = tuple(self._unique_results.keys())\n        for input_hash in input_hashes:\n            try:\n                cursor_result = self._unique_results.pop(input_hash)\n                cursor_result.close()\n            except Exception as exc:\n                self.logger.warning(\n                    f\"Failed to close connection for input hash {input_hash!r}: {exc}\"\n                )\n\n    @sync_compatible\n    async def reset_connections(self) -&gt; None:\n\"\"\"\n        Tries to close all opened connections and their results.\n\n        Examples:\n            Resets connections so `fetch_*` methods return new results.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                results = database.fetch_one(\"SELECT * FROM customers\")\n                database.reset_connections()\n                results = database.fetch_one(\"SELECT * FROM customers\")\n            ```\n        \"\"\"\n        if self._driver_is_async:\n            raise RuntimeError(\n                f\"{self._rendered_url.drivername} has no synchronous connections. \"\n                f\"Please use the `reset_async_connections` method instead.\"\n            )\n\n        if self._exit_stack is None:\n            self.logger.info(\"There were no connections to reset.\")\n            return\n\n        self._reset_cursor_results()\n        self._exit_stack.close()\n        self.logger.info(\"Reset opened connections and their results.\")\n\n    async def reset_async_connections(self) -&gt; None:\n\"\"\"\n        Tries to close all opened connections and their results.\n\n        Examples:\n            Resets connections so `fetch_*` methods return new results.\n            ```python\n            import asyncio\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            async def example_run():\n                async with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                    results = await database.fetch_one(\"SELECT * FROM customers\")\n                    await database.reset_async_connections()\n                    results = await database.fetch_one(\"SELECT * FROM customers\")\n\n            asyncio.run(example_run())\n            ```\n        \"\"\"\n        if not self._driver_is_async:\n            raise RuntimeError(\n                f\"{self._rendered_url.drivername} has no asynchronous connections. \"\n                f\"Please use the `reset_connections` method instead.\"\n            )\n\n        if self._exit_stack is None:\n            self.logger.info(\"There were no connections to reset.\")\n            return\n\n        self._reset_cursor_results()\n        await self._exit_stack.aclose()\n        self.logger.info(\"Reset opened connections and their results.\")\n\n    @sync_compatible\n    async def fetch_one(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        **execution_options: Dict[str, Any],\n    ) -&gt; Tuple[Any]:\n\"\"\"\n        Fetch a single result from the database.\n\n        Repeated calls using the same inputs to *any* of the fetch methods of this\n        block will skip executing the operation again, and instead,\n        return the next set of results from the previous execution,\n        until the reset_cursors method is called.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            **execution_options: Options to pass to `Connection.execution_options`.\n\n        Returns:\n            A list of tuples containing the data returned by the database,\n                where each row is a tuple and each column is a value in the tuple.\n\n        Examples:\n            Create a table, insert three rows into it, and fetch a row repeatedly.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n                database.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n                results = True\n                while results:\n                    results = database.fetch_one(\"SELECT * FROM customers\")\n                    print(results)\n            ```\n        \"\"\"  # noqa\n        result_set = await self._get_result_set(\n            text(operation), parameters, execution_options=execution_options\n        )\n        self.logger.debug(\"Preparing to fetch one row.\")\n        row = result_set.fetchone()\n        return row\n\n    @sync_compatible\n    async def fetch_many(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        size: Optional[int] = None,\n        **execution_options: Dict[str, Any],\n    ) -&gt; List[Tuple[Any]]:\n\"\"\"\n        Fetch a limited number of results from the database.\n\n        Repeated calls using the same inputs to *any* of the fetch methods of this\n        block will skip executing the operation again, and instead,\n        return the next set of results from the previous execution,\n        until the reset_cursors method is called.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            size: The number of results to return; if None or 0, uses the value of\n                `fetch_size` configured on the block.\n            **execution_options: Options to pass to `Connection.execution_options`.\n\n        Returns:\n            A list of tuples containing the data returned by the database,\n                where each row is a tuple and each column is a value in the tuple.\n\n        Examples:\n            Create a table, insert three rows into it, and fetch two rows repeatedly.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n                database.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n                results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n                print(results)\n                results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n                print(results)\n            ```\n        \"\"\"  # noqa\n        result_set = await self._get_result_set(\n            text(operation), parameters, execution_options=execution_options\n        )\n        size = size or self.fetch_size\n        self.logger.debug(f\"Preparing to fetch {size} rows.\")\n        rows = result_set.fetchmany(size=size)\n        return rows\n\n    @sync_compatible\n    async def fetch_all(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        **execution_options: Dict[str, Any],\n    ) -&gt; List[Tuple[Any]]:\n\"\"\"\n        Fetch all results from the database.\n\n        Repeated calls using the same inputs to *any* of the fetch methods of this\n        block will skip executing the operation again, and instead,\n        return the next set of results from the previous execution,\n        until the reset_cursors method is called.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            **execution_options: Options to pass to `Connection.execution_options`.\n\n        Returns:\n            A list of tuples containing the data returned by the database,\n                where each row is a tuple and each column is a value in the tuple.\n\n        Examples:\n            Create a table, insert three rows into it, and fetch all where name is 'Me'.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n                database.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n                results = database.fetch_all(\"SELECT * FROM customers WHERE name = :name\", parameters={\"name\": \"Me\"})\n            ```\n        \"\"\"  # noqa\n        result_set = await self._get_result_set(\n            text(operation), parameters, execution_options=execution_options\n        )\n        self.logger.debug(\"Preparing to fetch all rows.\")\n        rows = result_set.fetchall()\n        return rows\n\n    @sync_compatible\n    async def execute(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = None,\n        **execution_options: Dict[str, Any],\n    ) -&gt; None:\n\"\"\"\n        Executes an operation on the database. This method is intended to be used\n        for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n\n        Unlike the fetch methods, this method will always execute the operation\n        upon calling.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            parameters: The parameters for the operation.\n            **execution_options: Options to pass to `Connection.execution_options`.\n\n        Examples:\n            Create a table and insert one row into it.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n                database.execute(\n                    \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                    parameters={\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n                )\n            ```\n        \"\"\"  # noqa\n        async with self._manage_connection(begin=False) as connection:\n            await self._async_sync_execute(\n                connection,\n                text(operation),\n                parameters,\n                execution_options=execution_options,\n            )\n        self.logger.info(f\"Executed the operation, {operation!r}\")\n\n    @sync_compatible\n    async def execute_many(\n        self,\n        operation: str,\n        seq_of_parameters: List[Dict[str, Any]],\n        **execution_options: Dict[str, Any],\n    ) -&gt; None:\n\"\"\"\n        Executes many operations on the database. This method is intended to be used\n        for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n\n        Unlike the fetch methods, this method will always execute the operation\n        upon calling.\n\n        Args:\n            operation: The SQL query or other operation to be executed.\n            seq_of_parameters: The sequence of parameters for the operation.\n            **execution_options: Options to pass to `Connection.execution_options`.\n\n        Examples:\n            Create a table and insert two rows into it.\n            ```python\n            from prefect_sqlalchemy import SqlAlchemyConnector\n\n            with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n                database.execute_many(\n                    \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                    seq_of_parameters=[\n                        {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                        {\"name\": \"Unknown\", \"address\": \"Space\"},\n                        {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                    ],\n                )\n            ```\n        \"\"\"  # noqa\n        async with self._manage_connection(begin=False) as connection:\n            await self._async_sync_execute(\n                connection,\n                text(operation),\n                seq_of_parameters,\n                execution_options=execution_options,\n            )\n        self.logger.info(\n            f\"Executed {len(seq_of_parameters)} operations based off {operation!r}.\"\n        )\n\n    async def __aenter__(self):\n\"\"\"\n        Start an asynchronous database engine upon entry.\n        \"\"\"\n        if not self._driver_is_async:\n            raise RuntimeError(\n                f\"{self._rendered_url.drivername} cannot be run asynchronously. \"\n                f\"Please use the `with` syntax.\"\n            )\n        return self\n\n    async def __aexit__(self, *args):\n\"\"\"\n        Dispose the asynchronous database engine upon exit.\n        \"\"\"\n        await self.aclose()\n\n    async def aclose(self):\n\"\"\"\n        Closes async connections and its cursors.\n        \"\"\"\n        if not self._driver_is_async:\n            raise RuntimeError(\n                f\"{self._rendered_url.drivername} is not asynchronous. \"\n                f\"Please use the `close` method instead.\"\n            )\n        try:\n            await self.reset_async_connections()\n        finally:\n            if self._engine is not None:\n                await self._engine.dispose()\n                self._engine = None\n                self.logger.info(\"Disposed the engine.\")\n\n    def __enter__(self):\n\"\"\"\n        Start an synchronous database engine upon entry.\n        \"\"\"\n        if self._driver_is_async:\n            raise RuntimeError(\n                f\"{self._rendered_url.drivername} cannot be run synchronously. \"\n                f\"Please use the `async with` syntax.\"\n            )\n        return self\n\n    def __exit__(self, *args):\n\"\"\"\n        Dispose the synchronous database engine upon exit.\n        \"\"\"\n        self.close()\n\n    def close(self):\n\"\"\"\n        Closes sync connections and its cursors.\n        \"\"\"\n        if self._driver_is_async:\n            raise RuntimeError(\n                f\"{self._rendered_url.drivername} is not synchronous. \"\n                f\"Please use the `aclose` method instead.\"\n            )\n\n        try:\n            self.reset_connections()\n        finally:\n            if self._engine is not None:\n                self._engine.dispose()\n                self._engine = None\n                self.logger.info(\"Disposed the engine.\")\n\n    def __getstate__(self):\n\"\"\"Allows the block to be pickleable.\"\"\"\n        data = self.__dict__.copy()\n        data.update({k: None for k in {\"_engine\", \"_exit_stack\", \"_unique_results\"}})\n        return data\n\n    def __setstate__(self, data: dict):\n\"\"\"Upon loading back, restart the engine and results.\"\"\"\n        self.__dict__.update(data)\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector-classes","title":"Classes","text":""},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.Config","title":"<code>Config</code>","text":"<p>Configuration of pydantic.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>class Config:\n\"\"\"Configuration of pydantic.\"\"\"\n\n    # Support serialization of the 'URL' type\n    arbitrary_types_allowed = True\n    json_encoders = {URL: lambda u: u.render_as_string()}\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector-functions","title":"Functions","text":""},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.__aenter__","title":"<code>__aenter__</code>  <code>async</code>","text":"<p>Start an asynchronous database engine upon entry.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>async def __aenter__(self):\n\"\"\"\n    Start an asynchronous database engine upon entry.\n    \"\"\"\n    if not self._driver_is_async:\n        raise RuntimeError(\n            f\"{self._rendered_url.drivername} cannot be run asynchronously. \"\n            f\"Please use the `with` syntax.\"\n        )\n    return self\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.__aexit__","title":"<code>__aexit__</code>  <code>async</code>","text":"<p>Dispose the asynchronous database engine upon exit.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>async def __aexit__(self, *args):\n\"\"\"\n    Dispose the asynchronous database engine upon exit.\n    \"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.__enter__","title":"<code>__enter__</code>","text":"<p>Start an synchronous database engine upon entry.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def __enter__(self):\n\"\"\"\n    Start an synchronous database engine upon entry.\n    \"\"\"\n    if self._driver_is_async:\n        raise RuntimeError(\n            f\"{self._rendered_url.drivername} cannot be run synchronously. \"\n            f\"Please use the `async with` syntax.\"\n        )\n    return self\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.__exit__","title":"<code>__exit__</code>","text":"<p>Dispose the synchronous database engine upon exit.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def __exit__(self, *args):\n\"\"\"\n    Dispose the synchronous database engine upon exit.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.__getstate__","title":"<code>__getstate__</code>","text":"<p>Allows the block to be pickleable.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def __getstate__(self):\n\"\"\"Allows the block to be pickleable.\"\"\"\n    data = self.__dict__.copy()\n    data.update({k: None for k in {\"_engine\", \"_exit_stack\", \"_unique_results\"}})\n    return data\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.__setstate__","title":"<code>__setstate__</code>","text":"<p>Upon loading back, restart the engine and results.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def __setstate__(self, data: dict):\n\"\"\"Upon loading back, restart the engine and results.\"\"\"\n    self.__dict__.update(data)\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.aclose","title":"<code>aclose</code>  <code>async</code>","text":"<p>Closes async connections and its cursors.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>async def aclose(self):\n\"\"\"\n    Closes async connections and its cursors.\n    \"\"\"\n    if not self._driver_is_async:\n        raise RuntimeError(\n            f\"{self._rendered_url.drivername} is not asynchronous. \"\n            f\"Please use the `close` method instead.\"\n        )\n    try:\n        await self.reset_async_connections()\n    finally:\n        if self._engine is not None:\n            await self._engine.dispose()\n            self._engine = None\n            self.logger.info(\"Disposed the engine.\")\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.block_initialization","title":"<code>block_initialization</code>","text":"<p>Initializes the engine.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def block_initialization(self):\n\"\"\"\n    Initializes the engine.\n    \"\"\"\n    super().block_initialization()\n\n    if isinstance(self.connection_info, ConnectionComponents):\n        self._rendered_url = self.connection_info.create_url()\n    else:\n        # make rendered url from string\n        self._rendered_url = make_url(str(self.connection_info))\n    drivername = self._rendered_url.drivername\n\n    try:\n        AsyncDriver(drivername)\n        self._driver_is_async = True\n    except ValueError:\n        self._driver_is_async = False\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.close","title":"<code>close</code>","text":"<p>Closes sync connections and its cursors.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def close(self):\n\"\"\"\n    Closes sync connections and its cursors.\n    \"\"\"\n    if self._driver_is_async:\n        raise RuntimeError(\n            f\"{self._rendered_url.drivername} is not synchronous. \"\n            f\"Please use the `aclose` method instead.\"\n        )\n\n    try:\n        self.reset_connections()\n    finally:\n        if self._engine is not None:\n            self._engine.dispose()\n            self._engine = None\n            self.logger.info(\"Disposed the engine.\")\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.dict","title":"<code>dict</code>","text":"<p>Convert to a dictionary.</p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def dict(self, *args, **kwargs) -&gt; Dict:\n\"\"\"\n    Convert to a dictionary.\n    \"\"\"\n    # Support serialization of the 'URL' type\n    d = super().dict(*args, **kwargs)\n    d[\"_rendered_url\"] = SecretStr(\n        self._rendered_url.render_as_string(hide_password=False)\n    )\n    return d\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.execute","title":"<code>execute</code>  <code>async</code>","text":"<p>Executes an operation on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE.</p> <p>Unlike the fetch methods, this method will always execute the operation upon calling.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code> <code>**execution_options</code> <code>Dict[str, Any]</code> <p>Options to pass to <code>Connection.execution_options</code>.</p> <code>{}</code> <p>Examples:</p> <p>Create a table and insert one row into it. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        parameters={\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n    )\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@sync_compatible\nasync def execute(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    **execution_options: Dict[str, Any],\n) -&gt; None:\n\"\"\"\n    Executes an operation on the database. This method is intended to be used\n    for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n\n    Unlike the fetch methods, this method will always execute the operation\n    upon calling.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        **execution_options: Options to pass to `Connection.execution_options`.\n\n    Examples:\n        Create a table and insert one row into it.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n            database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n            database.execute(\n                \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                parameters={\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n            )\n        ```\n    \"\"\"  # noqa\n    async with self._manage_connection(begin=False) as connection:\n        await self._async_sync_execute(\n            connection,\n            text(operation),\n            parameters,\n            execution_options=execution_options,\n        )\n    self.logger.info(f\"Executed the operation, {operation!r}\")\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.execute_many","title":"<code>execute_many</code>  <code>async</code>","text":"<p>Executes many operations on the database. This method is intended to be used for operations that do not return data, such as INSERT, UPDATE, or DELETE.</p> <p>Unlike the fetch methods, this method will always execute the operation upon calling.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required <code>seq_of_parameters</code> <code>List[Dict[str, Any]]</code> <p>The sequence of parameters for the operation.</p> required <code>**execution_options</code> <code>Dict[str, Any]</code> <p>Options to pass to <code>Connection.execution_options</code>.</p> <code>{}</code> <p>Examples:</p> <p>Create a table and insert two rows into it. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@sync_compatible\nasync def execute_many(\n    self,\n    operation: str,\n    seq_of_parameters: List[Dict[str, Any]],\n    **execution_options: Dict[str, Any],\n) -&gt; None:\n\"\"\"\n    Executes many operations on the database. This method is intended to be used\n    for operations that do not return data, such as INSERT, UPDATE, or DELETE.\n\n    Unlike the fetch methods, this method will always execute the operation\n    upon calling.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        seq_of_parameters: The sequence of parameters for the operation.\n        **execution_options: Options to pass to `Connection.execution_options`.\n\n    Examples:\n        Create a table and insert two rows into it.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n            database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n            database.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n        ```\n    \"\"\"  # noqa\n    async with self._manage_connection(begin=False) as connection:\n        await self._async_sync_execute(\n            connection,\n            text(operation),\n            seq_of_parameters,\n            execution_options=execution_options,\n        )\n    self.logger.info(\n        f\"Executed {len(seq_of_parameters)} operations based off {operation!r}.\"\n    )\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.fetch_all","title":"<code>fetch_all</code>  <code>async</code>","text":"<p>Fetch all results from the database.</p> <p>Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code> <code>**execution_options</code> <code>Dict[str, Any]</code> <p>Options to pass to <code>Connection.execution_options</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Tuple[Any]]</code> <p>A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple.</p> <p>Examples:</p> <p>Create a table, insert three rows into it, and fetch all where name is 'Me'. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = database.fetch_all(\"SELECT * FROM customers WHERE name = :name\", parameters={\"name\": \"Me\"})\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@sync_compatible\nasync def fetch_all(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    **execution_options: Dict[str, Any],\n) -&gt; List[Tuple[Any]]:\n\"\"\"\n    Fetch all results from the database.\n\n    Repeated calls using the same inputs to *any* of the fetch methods of this\n    block will skip executing the operation again, and instead,\n    return the next set of results from the previous execution,\n    until the reset_cursors method is called.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        **execution_options: Options to pass to `Connection.execution_options`.\n\n    Returns:\n        A list of tuples containing the data returned by the database,\n            where each row is a tuple and each column is a value in the tuple.\n\n    Examples:\n        Create a table, insert three rows into it, and fetch all where name is 'Me'.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n            database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n            database.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            results = database.fetch_all(\"SELECT * FROM customers WHERE name = :name\", parameters={\"name\": \"Me\"})\n        ```\n    \"\"\"  # noqa\n    result_set = await self._get_result_set(\n        text(operation), parameters, execution_options=execution_options\n    )\n    self.logger.debug(\"Preparing to fetch all rows.\")\n    rows = result_set.fetchall()\n    return rows\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.fetch_many","title":"<code>fetch_many</code>  <code>async</code>","text":"<p>Fetch a limited number of results from the database.</p> <p>Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code> <code>size</code> <code>Optional[int]</code> <p>The number of results to return; if None or 0, uses the value of <code>fetch_size</code> configured on the block.</p> <code>None</code> <code>**execution_options</code> <code>Dict[str, Any]</code> <p>Options to pass to <code>Connection.execution_options</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Tuple[Any]]</code> <p>A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple.</p> <p>Examples:</p> <p>Create a table, insert three rows into it, and fetch two rows repeatedly. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n    print(results)\n    results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n    print(results)\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@sync_compatible\nasync def fetch_many(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    size: Optional[int] = None,\n    **execution_options: Dict[str, Any],\n) -&gt; List[Tuple[Any]]:\n\"\"\"\n    Fetch a limited number of results from the database.\n\n    Repeated calls using the same inputs to *any* of the fetch methods of this\n    block will skip executing the operation again, and instead,\n    return the next set of results from the previous execution,\n    until the reset_cursors method is called.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        size: The number of results to return; if None or 0, uses the value of\n            `fetch_size` configured on the block.\n        **execution_options: Options to pass to `Connection.execution_options`.\n\n    Returns:\n        A list of tuples containing the data returned by the database,\n            where each row is a tuple and each column is a value in the tuple.\n\n    Examples:\n        Create a table, insert three rows into it, and fetch two rows repeatedly.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n            database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n            database.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n            print(results)\n            results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n            print(results)\n        ```\n    \"\"\"  # noqa\n    result_set = await self._get_result_set(\n        text(operation), parameters, execution_options=execution_options\n    )\n    size = size or self.fetch_size\n    self.logger.debug(f\"Preparing to fetch {size} rows.\")\n    rows = result_set.fetchmany(size=size)\n    return rows\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.fetch_one","title":"<code>fetch_one</code>  <code>async</code>","text":"<p>Fetch a single result from the database.</p> <p>Repeated calls using the same inputs to any of the fetch methods of this block will skip executing the operation again, and instead, return the next set of results from the previous execution, until the reset_cursors method is called.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL query or other operation to be executed.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters for the operation.</p> <code>None</code> <code>**execution_options</code> <code>Dict[str, Any]</code> <p>Options to pass to <code>Connection.execution_options</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[Any]</code> <p>A list of tuples containing the data returned by the database, where each row is a tuple and each column is a value in the tuple.</p> <p>Examples:</p> <p>Create a table, insert three rows into it, and fetch a row repeatedly. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = True\n    while results:\n        results = database.fetch_one(\"SELECT * FROM customers\")\n        print(results)\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@sync_compatible\nasync def fetch_one(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = None,\n    **execution_options: Dict[str, Any],\n) -&gt; Tuple[Any]:\n\"\"\"\n    Fetch a single result from the database.\n\n    Repeated calls using the same inputs to *any* of the fetch methods of this\n    block will skip executing the operation again, and instead,\n    return the next set of results from the previous execution,\n    until the reset_cursors method is called.\n\n    Args:\n        operation: The SQL query or other operation to be executed.\n        parameters: The parameters for the operation.\n        **execution_options: Options to pass to `Connection.execution_options`.\n\n    Returns:\n        A list of tuples containing the data returned by the database,\n            where each row is a tuple and each column is a value in the tuple.\n\n    Examples:\n        Create a table, insert three rows into it, and fetch a row repeatedly.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n            database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n            database.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                seq_of_parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            results = True\n            while results:\n                results = database.fetch_one(\"SELECT * FROM customers\")\n                print(results)\n        ```\n    \"\"\"  # noqa\n    result_set = await self._get_result_set(\n        text(operation), parameters, execution_options=execution_options\n    )\n    self.logger.debug(\"Preparing to fetch one row.\")\n    row = result_set.fetchone()\n    return row\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.get_client","title":"<code>get_client</code>","text":"<p>Returns either an engine or connection that can be used to query from databases.</p> <p>Parameters:</p> Name Type Description Default <code>client_type</code> <code>Literal[engine, connection]</code> <p>Select from either 'engine' or 'connection'.</p> required <code>**get_client_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to either <code>get_engine</code> or <code>get_connection</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Engine, AsyncEngine, Connection, AsyncConnection]</code> <p>The authenticated SQLAlchemy engine or connection.</p> <p>Examples:</p> <p>Create an engine. <pre><code>from prefect_sqlalchemy import SqlalchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nengine = sqlalchemy_connector.get_client(client_type=\"engine\")\n</code></pre></p> <p>Create a context managed connection. <pre><code>from prefect_sqlalchemy import SqlalchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nwith sqlalchemy_connector.get_client(client_type=\"connection\") as conn:\n    ...\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def get_client(\n    self,\n    client_type: Literal[\"engine\", \"connection\"],\n    **get_client_kwargs: Dict[str, Any],\n) -&gt; Union[Engine, AsyncEngine, Connection, AsyncConnection]:\n\"\"\"\n    Returns either an engine or connection that can be used to query from databases.\n\n    Args:\n        client_type: Select from either 'engine' or 'connection'.\n        **get_client_kwargs: Additional keyword arguments to pass to\n            either `get_engine` or `get_connection`.\n\n    Returns:\n        The authenticated SQLAlchemy engine or connection.\n\n    Examples:\n        Create an engine.\n        ```python\n        from prefect_sqlalchemy import SqlalchemyConnector\n\n        sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n        engine = sqlalchemy_connector.get_client(client_type=\"engine\")\n        ```\n\n        Create a context managed connection.\n        ```python\n        from prefect_sqlalchemy import SqlalchemyConnector\n\n        sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n        with sqlalchemy_connector.get_client(client_type=\"connection\") as conn:\n            ...\n        ```\n    \"\"\"  # noqa: E501\n    if client_type == \"engine\":\n        client = self.get_engine(**get_client_kwargs)\n    elif client_type == \"connection\":\n        client = self.get_connection(**get_client_kwargs)\n    else:\n        raise ValueError(\n            f\"{client_type!r} is not supported; choose from engine or connection.\"\n        )\n    return client\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.get_connection","title":"<code>get_connection</code>","text":"<p>Returns a connection that can be used to query from databases.</p> <p>Parameters:</p> Name Type Description Default <code>begin</code> <code>bool</code> <p>Whether to begin a transaction on the connection; if True, if any operations fail, the entire transaction will be rolled back.</p> <code>True</code> <code>**connect_kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to pass to either <code>engine.begin</code> or engine.connect`.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Connection, AsyncConnection]</code> <p>The SQLAlchemy Connection / AsyncConnection.</p> <p>Examples:</p> <p>Create an synchronous connection as a context-managed transaction. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nwith sqlalchemy_connector.get_connection(begin=False) as connection:\n    connection.execute(\"SELECT * FROM table LIMIT 1;\")\n</code></pre></p> <p>Create an asynchronous connection as a context-managed transacation. <pre><code>import asyncio\nfrom prefect_sqlalchemy import SqlAlchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nasync with sqlalchemy_connector.get_connection(begin=False) as connection:\n    asyncio.run(connection.execute(\"SELECT * FROM table LIMIT 1;\"))\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def get_connection(\n    self, begin: bool = True, **connect_kwargs: Dict[str, Any]\n) -&gt; Union[Connection, AsyncConnection]:\n\"\"\"\n    Returns a connection that can be used to query from databases.\n\n    Args:\n        begin: Whether to begin a transaction on the connection; if True, if\n            any operations fail, the entire transaction will be rolled back.\n        **connect_kwargs: Additional keyword arguments to pass to either\n            `engine.begin` or engine.connect`.\n\n    Returns:\n        The SQLAlchemy Connection / AsyncConnection.\n\n    Examples:\n        Create an synchronous connection as a context-managed transaction.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n        with sqlalchemy_connector.get_connection(begin=False) as connection:\n            connection.execute(\"SELECT * FROM table LIMIT 1;\")\n        ```\n\n        Create an asynchronous connection as a context-managed transacation.\n        ```python\n        import asyncio\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        sqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\n        async with sqlalchemy_connector.get_connection(begin=False) as connection:\n            asyncio.run(connection.execute(\"SELECT * FROM table LIMIT 1;\"))\n        ```\n    \"\"\"  # noqa: E501\n    engine = self.get_engine()\n    if begin:\n        connection = engine.begin(**connect_kwargs)\n    else:\n        connection = engine.connect(**connect_kwargs)\n    self.logger.info(\"Created a new connection.\")\n    return connection\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.get_engine","title":"<code>get_engine</code>","text":"<p>Returns an authenticated engine that can be used to query from databases.</p> <p>If an existing engine exists, return that one.</p> <p>Returns:</p> Type Description <code>Union[Engine, AsyncEngine]</code> <p>The authenticated SQLAlchemy Engine / AsyncEngine.</p> <p>Examples:</p> <p>Create an asynchronous engine to PostgreSQL using URL params. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import (\n    SqlAlchemyConnector, ConnectionComponents, AsyncDriver\n)\n\n@flow\ndef sqlalchemy_credentials_flow():\n    sqlalchemy_credentials = SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n            driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n            username=\"prefect\",\n            password=\"prefect_password\",\n            database=\"postgres\"\n        )\n    )\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p> <p>Create a synchronous engine to Snowflake using the <code>url</code> kwarg. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import SqlAlchemyConnector, AsyncDriver\n\n@flow\ndef sqlalchemy_credentials_flow():\n    url = (\n        \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n        \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n        \"?warehouse=&lt;warehouse_name&gt;\"\n    )\n    sqlalchemy_credentials = SqlAlchemyConnector(url=url)\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>def get_engine(\n    self, **create_engine_kwargs: Dict[str, Any]\n) -&gt; Union[Engine, AsyncEngine]:\n\"\"\"\n    Returns an authenticated engine that can be\n    used to query from databases.\n\n    If an existing engine exists, return that one.\n\n    Returns:\n        The authenticated SQLAlchemy Engine / AsyncEngine.\n\n    Examples:\n        Create an asynchronous engine to PostgreSQL using URL params.\n        ```python\n        from prefect import flow\n        from prefect_sqlalchemy import (\n            SqlAlchemyConnector, ConnectionComponents, AsyncDriver\n        )\n\n        @flow\n        def sqlalchemy_credentials_flow():\n            sqlalchemy_credentials = SqlAlchemyConnector(\n            connection_info=ConnectionComponents(\n                    driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n                    username=\"prefect\",\n                    password=\"prefect_password\",\n                    database=\"postgres\"\n                )\n            )\n            print(sqlalchemy_credentials.get_engine())\n\n        sqlalchemy_credentials_flow()\n        ```\n\n        Create a synchronous engine to Snowflake using the `url` kwarg.\n        ```python\n        from prefect import flow\n        from prefect_sqlalchemy import SqlAlchemyConnector, AsyncDriver\n\n        @flow\n        def sqlalchemy_credentials_flow():\n            url = (\n                \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n                \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n                \"?warehouse=&lt;warehouse_name&gt;\"\n            )\n            sqlalchemy_credentials = SqlAlchemyConnector(url=url)\n            print(sqlalchemy_credentials.get_engine())\n\n        sqlalchemy_credentials_flow()\n        ```\n    \"\"\"\n    if self._engine is not None:\n        self.logger.debug(\"Reusing existing engine.\")\n        return self._engine\n\n    engine_kwargs = dict(\n        url=self._rendered_url,\n        connect_args=self.connect_args or {},\n        **create_engine_kwargs,\n    )\n    if self._driver_is_async:\n        # no need to await here\n        engine = create_async_engine(**engine_kwargs)\n    else:\n        engine = create_engine(**engine_kwargs)\n    self.logger.info(\"Created a new engine.\")\n\n    if self._engine is None:\n        self._engine = engine\n    if self._exit_stack is None:\n        self._start_exit_stack()\n    if self._unique_results is None:\n        self._unique_results = {}\n\n    return engine\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.reset_async_connections","title":"<code>reset_async_connections</code>  <code>async</code>","text":"<p>Tries to close all opened connections and their results.</p> <p>Examples:</p> <p>Resets connections so <code>fetch_*</code> methods return new results. <pre><code>import asyncio\nfrom prefect_sqlalchemy import SqlAlchemyConnector\n\nasync def example_run():\n    async with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n        results = await database.fetch_one(\"SELECT * FROM customers\")\n        await database.reset_async_connections()\n        results = await database.fetch_one(\"SELECT * FROM customers\")\n\nasyncio.run(example_run())\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>async def reset_async_connections(self) -&gt; None:\n\"\"\"\n    Tries to close all opened connections and their results.\n\n    Examples:\n        Resets connections so `fetch_*` methods return new results.\n        ```python\n        import asyncio\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        async def example_run():\n            async with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n                results = await database.fetch_one(\"SELECT * FROM customers\")\n                await database.reset_async_connections()\n                results = await database.fetch_one(\"SELECT * FROM customers\")\n\n        asyncio.run(example_run())\n        ```\n    \"\"\"\n    if not self._driver_is_async:\n        raise RuntimeError(\n            f\"{self._rendered_url.drivername} has no asynchronous connections. \"\n            f\"Please use the `reset_connections` method instead.\"\n        )\n\n    if self._exit_stack is None:\n        self.logger.info(\"There were no connections to reset.\")\n        return\n\n    self._reset_cursor_results()\n    await self._exit_stack.aclose()\n    self.logger.info(\"Reset opened connections and their results.\")\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.SqlAlchemyConnector.reset_connections","title":"<code>reset_connections</code>  <code>async</code>","text":"<p>Tries to close all opened connections and their results.</p> <p>Examples:</p> <p>Resets connections so <code>fetch_*</code> methods return new results. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    results = database.fetch_one(\"SELECT * FROM customers\")\n    database.reset_connections()\n    results = database.fetch_one(\"SELECT * FROM customers\")\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@sync_compatible\nasync def reset_connections(self) -&gt; None:\n\"\"\"\n    Tries to close all opened connections and their results.\n\n    Examples:\n        Resets connections so `fetch_*` methods return new results.\n        ```python\n        from prefect_sqlalchemy import SqlAlchemyConnector\n\n        with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n            results = database.fetch_one(\"SELECT * FROM customers\")\n            database.reset_connections()\n            results = database.fetch_one(\"SELECT * FROM customers\")\n        ```\n    \"\"\"\n    if self._driver_is_async:\n        raise RuntimeError(\n            f\"{self._rendered_url.drivername} has no synchronous connections. \"\n            f\"Please use the `reset_async_connections` method instead.\"\n        )\n\n    if self._exit_stack is None:\n        self.logger.info(\"There were no connections to reset.\")\n        return\n\n    self._reset_cursor_results()\n    self._exit_stack.close()\n    self.logger.info(\"Reset opened connections and their results.\")\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database-functions","title":"Functions","text":""},{"location":"database/#prefect_sqlalchemy.database.sqlalchemy_execute","title":"<code>sqlalchemy_execute</code>  <code>async</code>","text":"<p>Executes a SQL DDL or DML statement; useful for creating tables and inserting rows since this task does not return any objects.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>str</code> <p>The statement to execute against the database.</p> required <code>sqlalchemy_credentials</code> <code>DatabaseCredentials</code> <p>The credentials to use to authenticate.</p> required <code>params</code> <code>Optional[Union[Tuple[Any], Dict[str, Any]]]</code> <p>The params to replace the placeholders in the query.</p> <code>None</code> <p>Examples:</p> <p>Create table named customers and insert values. <pre><code>from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\nfrom prefect_sqlalchemy.database import sqlalchemy_execute\nfrom prefect import flow\n\n@flow\ndef sqlalchemy_execute_flow():\n    sqlalchemy_credentials = DatabaseCredentials(\n        driver=AsyncDriver.SQLITE_AIOSQLITE,\n        database=\"prefect.db\",\n    )\n    sqlalchemy_execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\",\n        sqlalchemy_credentials,\n    )\n    sqlalchemy_execute(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        sqlalchemy_credentials,\n        params={\"name\": \"Marvin\", \"address\": \"Highway 42\"}\n    )\n\nsqlalchemy_execute_flow()\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@task\nasync def sqlalchemy_execute(\n    statement: str,\n    sqlalchemy_credentials: \"DatabaseCredentials\",\n    params: Optional[Union[Tuple[Any], Dict[str, Any]]] = None,\n):\n\"\"\"\n    Executes a SQL DDL or DML statement; useful for creating tables and inserting rows\n    since this task does not return any objects.\n\n    Args:\n        statement: The statement to execute against the database.\n        sqlalchemy_credentials: The credentials to use to authenticate.\n        params: The params to replace the placeholders in the query.\n\n    Examples:\n        Create table named customers and insert values.\n        ```python\n        from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n        from prefect_sqlalchemy.database import sqlalchemy_execute\n        from prefect import flow\n\n        @flow\n        def sqlalchemy_execute_flow():\n            sqlalchemy_credentials = DatabaseCredentials(\n                driver=AsyncDriver.SQLITE_AIOSQLITE,\n                database=\"prefect.db\",\n            )\n            sqlalchemy_execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\",\n                sqlalchemy_credentials,\n            )\n            sqlalchemy_execute(\n                \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n                sqlalchemy_credentials,\n                params={\"name\": \"Marvin\", \"address\": \"Highway 42\"}\n            )\n\n        sqlalchemy_execute_flow()\n        ```\n    \"\"\"\n    warnings.warn(\n        \"sqlalchemy_query is now deprecated and will be removed March 2023; \"\n        \"please use SqlAlchemyConnector execute_* methods instead.\",\n        DeprecationWarning,\n    )\n    # do not return anything or else results in the error:\n    # This result object does not return rows. It has been closed automatically\n    engine = sqlalchemy_credentials.get_engine()\n    async_supported = sqlalchemy_credentials._driver_is_async\n    async with _connect(engine, async_supported) as connection:\n        await _execute(connection, statement, params, async_supported)\n</code></pre>"},{"location":"database/#prefect_sqlalchemy.database.sqlalchemy_query","title":"<code>sqlalchemy_query</code>  <code>async</code>","text":"<p>Executes a SQL query; useful for querying data from existing tables.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute against the database.</p> required <code>sqlalchemy_credentials</code> <code>DatabaseCredentials</code> <p>The credentials to use to authenticate.</p> required <code>params</code> <code>Optional[Union[Tuple[Any], Dict[str, Any]]]</code> <p>The params to replace the placeholders in the query.</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>The number of rows to fetch. Note, this parameter is executed on the client side, i.e. passed to <code>fetchmany</code>. To limit on the server side, add the <code>LIMIT</code> clause, or the dialect's equivalent clause, like <code>TOP</code>, to the query.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Tuple[Any]]</code> <p>The fetched results.</p> <p>Examples:</p> <p>Query postgres table with the ID value parameterized. <pre><code>from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\nfrom prefect_sqlalchemy.database import sqlalchemy_query\nfrom prefect import flow\n\n@flow\ndef sqlalchemy_query_flow():\n    sqlalchemy_credentials = DatabaseCredentials(\n        driver=AsyncDriver.SQLITE_AIOSQLITE,\n        database=\"prefect.db\",\n    )\n    result = sqlalchemy_query(\n        \"SELECT * FROM customers WHERE name = :name;\",\n        sqlalchemy_credentials,\n        params={\"name\": \"Marvin\"},\n    )\n    return result\n\nsqlalchemy_query_flow()\n</code></pre></p> Source code in <code>prefect_sqlalchemy/database.py</code> <pre><code>@task\nasync def sqlalchemy_query(\n    query: str,\n    sqlalchemy_credentials: \"DatabaseCredentials\",\n    params: Optional[Union[Tuple[Any], Dict[str, Any]]] = None,\n    limit: Optional[int] = None,\n) -&gt; List[Tuple[Any]]:\n\"\"\"\n    Executes a SQL query; useful for querying data from existing tables.\n\n    Args:\n        query: The query to execute against the database.\n        sqlalchemy_credentials: The credentials to use to authenticate.\n        params: The params to replace the placeholders in the query.\n        limit: The number of rows to fetch. Note, this parameter is\n            executed on the client side, i.e. passed to `fetchmany`.\n            To limit on the server side, add the `LIMIT` clause, or\n            the dialect's equivalent clause, like `TOP`, to the query.\n\n    Returns:\n        The fetched results.\n\n    Examples:\n        Query postgres table with the ID value parameterized.\n        ```python\n        from prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n        from prefect_sqlalchemy.database import sqlalchemy_query\n        from prefect import flow\n\n        @flow\n        def sqlalchemy_query_flow():\n            sqlalchemy_credentials = DatabaseCredentials(\n                driver=AsyncDriver.SQLITE_AIOSQLITE,\n                database=\"prefect.db\",\n            )\n            result = sqlalchemy_query(\n                \"SELECT * FROM customers WHERE name = :name;\",\n                sqlalchemy_credentials,\n                params={\"name\": \"Marvin\"},\n            )\n            return result\n\n        sqlalchemy_query_flow()\n        ```\n    \"\"\"\n    warnings.warn(\n        \"sqlalchemy_query is now deprecated and will be removed March 2023; \"\n        \"please use SqlAlchemyConnector fetch_* methods instead.\",\n        DeprecationWarning,\n    )\n    engine = sqlalchemy_credentials.get_engine()\n    async_supported = sqlalchemy_credentials._driver_is_async\n    async with _connect(engine, async_supported) as connection:\n        result = await _execute(connection, query, params, async_supported)\n        # some databases, like sqlite, require a connection still open to fetch!\n        rows = result.fetchall() if limit is None else result.fetchmany(limit)\n    return rows\n</code></pre>"},{"location":"examples_catalog/","title":"Examples Catalog","text":"<p>Below is a list of examples for <code>prefect-sqlalchemy</code>.</p>"},{"location":"examples_catalog/#credentials-module","title":"Credentials Module","text":"<p>Create an asynchronous engine to PostgreSQL using URL params. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n@flow\ndef sqlalchemy_credentials_flow():\n    sqlalchemy_credentials = DatabaseCredentials(\n        driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n        username=\"prefect\",\n        password=\"prefect_password\",\n        database=\"postgres\"\n    )\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p> <p>Create a synchronous engine to Snowflake using the <code>url</code> kwarg. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import DatabaseCredentials, AsyncDriver\n\n@flow\ndef sqlalchemy_credentials_flow():\n    url = (\n        \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n        \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n        \"?warehouse=&lt;warehouse_name&gt;\"\n    )\n    sqlalchemy_credentials = DatabaseCredentials(url=url)\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p>"},{"location":"examples_catalog/#database-module","title":"Database Module","text":"<p>Create a table and insert two rows into it. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n</code></pre> Create an asynchronous engine to PostgreSQL using URL params. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import (\n    SqlAlchemyConnector, ConnectionComponents, AsyncDriver\n)\n\n@flow\ndef sqlalchemy_credentials_flow():\n    sqlalchemy_credentials = SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n            driver=AsyncDriver.POSTGRESQL_ASYNCPG,\n            username=\"prefect\",\n            password=\"prefect_password\",\n            database=\"postgres\"\n        )\n    )\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre></p> <p>Create a synchronous engine to Snowflake using the <code>url</code> kwarg. <pre><code>from prefect import flow\nfrom prefect_sqlalchemy import SqlAlchemyConnector, AsyncDriver\n\n@flow\ndef sqlalchemy_credentials_flow():\n    url = (\n        \"snowflake://&lt;user_login_name&gt;:&lt;password&gt;\"\n        \"@&lt;account_identifier&gt;/&lt;database_name&gt;\"\n        \"?warehouse=&lt;warehouse_name&gt;\"\n    )\n    sqlalchemy_credentials = SqlAlchemyConnector(url=url)\n    print(sqlalchemy_credentials.get_engine())\n\nsqlalchemy_credentials_flow()\n</code></pre> Create a table, insert three rows into it, and fetch all where name is 'Me'. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = database.fetch_all(\"SELECT * FROM customers WHERE name = :name\", parameters={\"name\": \"Me\"})\n</code></pre> Create an engine. <pre><code>from prefect_sqlalchemy import SqlalchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nengine = sqlalchemy_connector.get_client(client_type=\"engine\")\n</code></pre></p> <p>Create a context managed connection. <pre><code>from prefect_sqlalchemy import SqlalchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nwith sqlalchemy_connector.get_client(client_type=\"connection\") as conn:\n    ...\n</code></pre> Resets connections so <code>fetch_*</code> methods return new results. <pre><code>import asyncio\nfrom prefect_sqlalchemy import SqlAlchemyConnector\n\nasync def example_run():\n    async with SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n        results = await database.fetch_one(\"SELECT * FROM customers\")\n        await database.reset_async_connections()\n        results = await database.fetch_one(\"SELECT * FROM customers\")\n\nasyncio.run(example_run())\n</code></pre> Create a table, insert three rows into it, and fetch two rows repeatedly. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n    print(results)\n    results = database.fetch_many(\"SELECT * FROM customers\", size=2)\n    print(results)\n</code></pre> Load stored database credentials and use in context manager: <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\ndatabase_block = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nwith database_block:\n    ...\n</code></pre></p> <p>Create table named customers and insert values; then fetch the first 10 rows. <pre><code>from prefect_sqlalchemy import (\n    SqlAlchemyConnector, SyncDriver, ConnectionComponents\n)\n\nwith SqlAlchemyConnector(\n    connection_info=ConnectionComponents(\n        driver=SyncDriver.SQLITE_PYSQLITE,\n        database=\"prefect.db\"\n    )\n) as database:\n    database.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\",\n    )\n    for i in range(1, 42):\n        database.execute(\n            \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n            parameters={\"name\": \"Marvin\", \"address\": f\"Highway {i}\"},\n        )\n    results = database.fetch_many(\n        \"SELECT * FROM customers WHERE name = :name;\",\n        parameters={\"name\": \"Marvin\"},\n        size=10\n    )\nprint(results)\n</code></pre> Create an synchronous connection as a context-managed transaction. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nwith sqlalchemy_connector.get_connection(begin=False) as connection:\n    connection.execute(\"SELECT * FROM table LIMIT 1;\")\n</code></pre></p> <p>Create an asynchronous connection as a context-managed transacation. <pre><code>import asyncio\nfrom prefect_sqlalchemy import SqlAlchemyConnector\n\nsqlalchemy_connector = SqlAlchemyConnector.load(\"BLOCK_NAME\")\nasync with sqlalchemy_connector.get_connection(begin=False) as connection:\n    asyncio.run(connection.execute(\"SELECT * FROM table LIMIT 1;\"))\n</code></pre> Create a table and insert one row into it. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        parameters={\"name\": \"Marvin\", \"address\": \"Highway 42\"},\n    )\n</code></pre> Resets connections so <code>fetch_*</code> methods return new results. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    results = database.fetch_one(\"SELECT * FROM customers\")\n    database.reset_connections()\n    results = database.fetch_one(\"SELECT * FROM customers\")\n</code></pre> Create a table, insert three rows into it, and fetch a row repeatedly. <pre><code>from prefect_sqlalchemy import SqlAlchemyConnector\n\nwith SqlAlchemyConnector.load(\"MY_BLOCK\") as database:\n    database.execute(\"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\")\n    database.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (:name, :address);\",\n        seq_of_parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = True\n    while results:\n        results = database.fetch_one(\"SELECT * FROM customers\")\n        print(results)\n</code></pre></p>"}]}